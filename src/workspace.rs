use crate::error::{NoetError, Result};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

const WORKSPACE_DIR: &str = ".noet";
const WORKSPACE_CONFIG: &str = "config.toml";

/// Get the workspace root directory by searching upwards from current directory
pub fn find_workspace_root() -> Result<PathBuf> {
    let current_dir = env::current_dir()?;
    find_workspace_root_from(&current_dir)
}

fn find_workspace_root_from(start_dir: &Path) -> Result<PathBuf> {
    let mut current = start_dir;

    loop {
        let workspace_dir = current.join(WORKSPACE_DIR);
        if workspace_dir.exists() && workspace_dir.is_dir() {
            return Ok(current.to_path_buf());
        }

        match current.parent() {
            Some(parent) => current = parent,
            None => {
                return Err(NoetError::ConfigError(
                    "Not in a noet workspace. Run 'noet init' to initialize.".to_string(),
                ))
            }
        }
    }
}

/// Initialize a workspace in the specified directory
pub fn init_workspace(path: Option<PathBuf>) -> Result<PathBuf> {
    let workspace_root = match path {
        Some(p) => {
            if p.is_relative() {
                env::current_dir()?.join(p)
            } else {
                p
            }
        }
        None => env::current_dir()?,
    };

    // Create workspace directory
    let workspace_dir = workspace_root.join(WORKSPACE_DIR);
    fs::create_dir_all(&workspace_dir)?;

    // Create default config
    let config_path = workspace_dir.join(WORKSPACE_CONFIG);
    if !config_path.exists() {
        let default_config = r#"# noet workspace configuration
# This file is automatically generated

[workspace]
# Workspace root directory
root = "."

[article]
# Default article status
default_status = "draft"

# Default tags
# default_tags = ["tag1", "tag2"]
"#;
        fs::write(&config_path, default_config)?;
    }

    // Create templates directory
    let templates_dir = workspace_root.join("templates");
    if !templates_dir.exists() {
        fs::create_dir_all(&templates_dir)?;
    }

    // Create .gitignore for .noet directory
    let gitignore_path = workspace_root.join(".gitignore");
    let gitignore_content = if gitignore_path.exists() {
        fs::read_to_string(&gitignore_path)?
    } else {
        String::new()
    };

    if !gitignore_content.contains(".noet") {
        let mut new_content = gitignore_content;
        if !new_content.is_empty() && !new_content.ends_with('\n') {
            new_content.push('\n');
        }
        new_content.push_str("\n# noet workspace\n.noet/\n");
        fs::write(&gitignore_path, new_content)?;
    }

    Ok(workspace_root)
}

/// Get the workspace directory (.noet/)
#[allow(dead_code)]
pub fn get_workspace_dir() -> Result<PathBuf> {
    let root = find_workspace_root()?;
    Ok(root.join(WORKSPACE_DIR))
}

/// Get the templates directory within workspace
pub fn get_templates_dir() -> Result<PathBuf> {
    let root = find_workspace_root()?;
    Ok(root.join("templates"))
}

/// Check if current directory is within a workspace
pub fn is_in_workspace() -> bool {
    find_workspace_root().is_ok()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_init_workspace() {
        let temp_dir = TempDir::new().unwrap();
        let workspace_root = init_workspace(Some(temp_dir.path().to_path_buf())).unwrap();

        assert!(workspace_root.join(".noet").exists());
        assert!(workspace_root.join(".noet/config.toml").exists());
        assert!(workspace_root.join("templates").exists());
    }

    #[test]
    fn test_find_workspace_root_from_subdirectory() {
        let temp_dir = TempDir::new().unwrap();
        let workspace_root = temp_dir.path();

        // Initialize workspace
        fs::create_dir_all(workspace_root.join(".noet")).unwrap();

        // Create subdirectory
        let subdir = workspace_root.join("articles/drafts");
        fs::create_dir_all(&subdir).unwrap();

        // Should find workspace root from subdirectory
        let found_root = find_workspace_root_from(&subdir).unwrap();
        assert_eq!(found_root, workspace_root);
    }

    #[test]
    fn test_find_workspace_root_not_found() {
        let temp_dir = TempDir::new().unwrap();
        let result = find_workspace_root_from(temp_dir.path());
        assert!(result.is_err());
    }
}
